\documentclass[UTF8]{ctexart}
\documentclass[a4paper]{article}

\usepackage{listings,xcolor}
\usepackage{graphicx}
\usepackage[a4paper,left=25.4mm,right=25.4mm,top=29.8mm,bottom=29.8mm]{geometry}

\lstset{numbers=left,
    commentstyle=\color{blue!50},
    columns=flexible}

\title{作业二：BST 排序算法的实现}

\author{张竣凯 \\ 3210300361 \\ 数学与应用数学}

\begin{document}

\maketitle

二叉搜索书的定义

\begin{flushright}
——摘自百度百科《XXX》
\end{flushright}

\section{设计思路}

\subsection{阅读并理解课本所提供的头文件 BinarySearchTree.h 里头编写的所有代码}
\hphantom 空例如：class BinarySearchTree 以及其功能函数等

\subsection{阅读并理解课本所提供的头文件 dsexceptions.h 里头编写的所有代码}
\hphantom 空例如：class UnderflowException、IllegalArgumentException 等

\subsection{编写测试程序 main.cpp 并适当地添加注释以方便理解代码}
\hphantom 空例如：Node结构中包含数据以及两个指针

\subsection{分别测试_mode = 0 的最坏效率和_mode = 1时的平均效率，并记录结果}
\hphantom 空例如：Iterator类中的各种运算符重载函数等

\subsection{}
\hphantom 空例如：begin函数、end函数、size函数等

\subsection{在 main.cpp 主流程里头编写外部函数find以及测试程序}
\hphantom 空尽可能地使用引用&以减少内部复制，以及充分考虑必要的const限制以提高安全性

\newpage

\section{额外函数}

\subsection{BSTSorting 函数}

\begin{lstlisting}[language={[ANSI]C++}]
template <typename Comparable>
void BSTSorting(std::vector<Comparable> &_arr, int _mode = 0)
{
    if(_mode == 1)
    {
        random_shuffle(_arr.begin(),_arr.end());
        cout << "开始进行 _mode = 1（乱序）的排序，数组的大小为" << _arr.size() 
             << "，重复进行10次后取平均值。" << endl;
        BinarySearchTree<Comparable> bst; //构造一个二叉搜索树bst
        double average_duration;
        for(int j=1; j<=10; j++)
        {
            clock_t begin_time = clock(); //将起始时间赋值于begin_time
            for(int i=0; i < _arr.size(); i++) //将_arr中的元素一个一个插入bst
                bst.insert(_arr[i]);
            clock_t end_time = clock(); //将终止时间赋值于end_time
            average_duration += (double)(end_time - begin_time)/CLOCKS_PER_SEC;
        }
        average_duration /= 10; //duration即为该过程运行的时长，以秒为单位
        cout << "排序结束，平均排序时长为" << average_duration << "秒。\v" << endl;
    }
    else
    {
        cout << "开始进行 _mode = 0（不乱序）的排序，数组的大小为" << _arr.size() 
             << "。" << endl;
        BinarySearchTree<Comparable> bst; //构造一个二叉搜索树bst
        clock_t begin_time = clock(); //将起始时间赋值于begin_time
        for(int i=0; i < _arr.size(); i++) //将_arr中的元素一个一个插入bst
            bst.insert(_arr[i]);
        clock_t end_time = clock(); //将终止时间赋值于end_time
        double duration = (double)(end_time - begin_time)/CLOCKS_PER_SEC;
        cout << "排序结束，排序时长为" << duration << "秒。\v" << endl;
    }
};
\end{lstlisting}

\newpage

\subsection{测试函数}

\begin{lstlisting}[language={[ANSI]C++}]
void mode0_test(int n) //用于测试 _mode = 0 的最坏效率
{
  vector<double> _arr; //构造一个向量_arr
  
  for(int i = 1; i <= n; i++) //通过for循环将元素1到n依次插入_arr
     _arr.push_back(i);
     
  BSTSorting(_arr, 0); //调用BSTSorting函数来排序_arr
}

void mode1_test(int n) //用于测试 _mode = 1 的平均效率
{
  vector<double> _arr; //构造一个向量_arr
  
  for(int i = 1; i <= n; i++) //通过for循环将元素1到n依次插入_arr
    _arr.push_back(i);

  BSTSorting(_arr, 1);  //调用BSTSorting函数来排序_arr
}
\end{lstlisting}

\subsection{main 函数}

\begin{lstlisting}[language={[ANSI]C++}]
int main()
{
  for(int i = 10000; i <= 50000; i+=10000) //调用测试函数，进行五次不同大小的数组排序
        mode0_test(i);
        
  for(int i = 10000; i <= 50000; i+=10000) //调用测试函数，进行五次不同大小的数组排序
        mode1_test(i);

  return 0;
}
\end{lstlisting}

\newpage

\section{测试说明与结果}

将main.cpp、BinarySearchTree.h与dsexceptions.h三个文件放入项目bst后，在该目录下进入终端，找到bst的路径后，输入g++ -o test main.cpp后回车，接着输入./test后回车，将会出现以下结果：

\begin{flushleft}
开始进行 \_mode = 0（不乱序）的排序，向量的大小为10000。\\
排序结束，排序时长为0.606883秒。\\
\addvspace{10}
开始进行 \_mode = 0（不乱序）的排序，向量的大小为20000。\\
排序结束，排序时长为2.21933秒。\\
\addvspace{10}
开始进行 \_mode = 0（不乱序）的排序，向量的大小为30000。\\
排序结束，排序时长为4.46622秒。\\
\addvspace{10}
开始进行 \_mode = 0（不乱序）的排序，向量的大小为40000。\\
排序结束，排序时长为8.07494秒。\\
\addvspace{10}
开始进行 \_mode = 0（不乱序）的排序，向量的大小为50000。\\
排序结束，排序时长为12.6013秒。\\
\addvspace{10}
开始进行 \_mode = 1（乱序）的排序，向量的大小为10000，重复进行10次后取平均值。\\
排序结束，平均排序时长为0.0019587秒。\\
\addvspace{10}
开始进行 \_mode = 1（乱序）的排序，向量的大小为20000，重复进行10次后取平均值。\\
排序结束，平均排序时长为0.004505秒。\\
\addvspace{10}
开始进行 \_mode = 1（乱序）的排序，向量的大小为30000，重复进行10次后取平均值。\\
排序结束，平均排序时长为0.007485秒。\\
\addvspace{10}
开始进行 \_mode = 1（乱序）的排序，向量的大小为40000，重复进行10次后取平均值。\\
排序结束，平均排序时长为0.0101757秒。\\
\addvspace{10}
开始进行 \_mode = 1（乱序）的排序，向量的大小为50000，重复进行10次后取平均值。\\
排序结束，平均排序时长为0.0131516秒。\\
\end{flushleft}

不难从上面的测试结果发现，在数组不进行排序的情况下（\_mode = 0），当数组的大小分别为10000、20000、30000、40000及50000时，排序所需的时间大约分别为0.61秒、2.22秒、4.47秒、8.08秒及12.6秒,因此得到 \_mode = 0 的最坏效率为 $O(n^2)$。\\

\\再来，在数组进行排序的情况下（\_mode = 1），当数组的大小分别为10000、20000、30000、40000及50000时，排序所需的平均时间大约分别为$1.96*10^{-3}$秒、$4.50*10^{-3}$秒、$7.49*10^{-3}$秒、$1.02*10^{-2}$秒及$1.32*10^{-2}$秒，因此得到 \_mode = 1 的平均效率为 $O(nlogn)$。\\

\\从结果来看，没经过乱序的数组进行二叉排序所需的时间是远大于经过乱序的数组的，因此在日后若有需要用到时，应当选择先进行乱序后再进行二叉排序，方能大幅地提升算法的效率。
\newpage

\section{内存泄漏检查}

承接上个部分，继续在终端中输入valgrind ./test后回车，将会出现以下结果

\begin{flushleft}
==2878== \\
==2878== HEAP SUMMARY: \\
==2878==     in use at exit: 0 bytes in 0 blocks \\
==2878==   total heap usage: 9 allocs, 9 frees, 73,896 bytes allocated \\
==2878== \\
==2878== All heap blocks were freed -- no leaks are possible \\
==2878== \\
==2878== For lists of detected and suppressed errors, rerun with: -s \\
==2878== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) \\
\end{flushleft}

\end{document}
